<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='本文是转载，出处不可考
内联变量——保证变量唯一性的利器 # 在 C++ 中，一个定义了全局变量的头文件被多个源文件包含时，每个源文件都会创建该全局变量的一个实例，这可能导致链接时出现重定义错误，代码示例如下。
// example.h #ifndef EXAMPLE_H #define EXAMPLE_H int globalVar = 42; #endif // EXAMPLE_H // file1.cpp #include "example.h" // Some code using globalVar // file2.cpp #include "example.h" // Some other code using globalVar 头文件中的变量globalVar会在file1.cpp和file2.cpp中分别创建实例，出现重定义的链接错误，MSVC的错误为LNK2005和LNK1169。
这是小编遇到的实际问题，在封装spdlog时，为了在宏内使用封装的对象，定义了全局变量，由于该日志类头文件被多个文件包含出现了链接错误。简化后的代码如下：
//log.h Log logger; // Define macros for different log levels #define LOG_DEBUG(msg) logger.Log(LogLevel::Debug,__FUNCTION__,__LINE__, msg) 为了解决全局变量的重定义问题，C++17引入了内联变量的概念。
内联变量
使用 inline 关键字可以将变量声明为内联变量，在多个源文件中包含该头文件时，编译器只会创建一个该变量的实例。
如上实例中定义的全局变量globalVar可以修改为内敛变量，如下
// example.h #ifndef EXAMPLE_H #define EXAMPLE_H inline int globalVar = 42; #endif // EXAMPLE_H 使用场景'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="内联变量——保证变量唯一性的利器"><meta property="og:description" content='本文是转载，出处不可考
内联变量——保证变量唯一性的利器 # 在 C++ 中，一个定义了全局变量的头文件被多个源文件包含时，每个源文件都会创建该全局变量的一个实例，这可能导致链接时出现重定义错误，代码示例如下。
// example.h #ifndef EXAMPLE_H #define EXAMPLE_H int globalVar = 42; #endif // EXAMPLE_H // file1.cpp #include "example.h" // Some code using globalVar // file2.cpp #include "example.h" // Some other code using globalVar 头文件中的变量globalVar会在file1.cpp和file2.cpp中分别创建实例，出现重定义的链接错误，MSVC的错误为LNK2005和LNK1169。
这是小编遇到的实际问题，在封装spdlog时，为了在宏内使用封装的对象，定义了全局变量，由于该日志类头文件被多个文件包含出现了链接错误。简化后的代码如下：
//log.h Log logger; // Define macros for different log levels #define LOG_DEBUG(msg) logger.Log(LogLevel::Debug,__FUNCTION__,__LINE__, msg) 为了解决全局变量的重定义问题，C++17引入了内联变量的概念。
内联变量
使用 inline 关键字可以将变量声明为内联变量，在多个源文件中包含该头文件时，编译器只会创建一个该变量的实例。
如上实例中定义的全局变量globalVar可以修改为内敛变量，如下
// example.h #ifndef EXAMPLE_H #define EXAMPLE_H inline int globalVar = 42; #endif // EXAMPLE_H 使用场景'><meta property="og:type" content="article"><meta property="og:url" content="https://example.com/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E5%88%A9%E5%99%A8/"><meta property="article:section" content="c++杂谈"><meta property="article:published_time" content="2024-04-10T11:15:07+08:00"><meta property="article:modified_time" content="2024-04-10T11:15:07+08:00"><title>内联变量——保证变量唯一性的利器 | 杨云召的技术博客</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://example.com/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E5%88%A9%E5%99%A8/><link rel=stylesheet href=/book.min.f8de3645fe00591b41524aee174e19edd98a22255a2930a0cdc82a94835ba387.css integrity="sha256-+N42Rf4AWRtBUkruF04Z7dmKIiVaKTCgzcgqlINbo4c=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.ad9e41ce2f902f8134ae67097ce0b77a09d2e16ecd736899b145ee7d5a7e2d43.js integrity="sha256-rZ5Bzi+QL4E0rmcJfOC3egnS4W7Nc2iZsUXufVp+LUM=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>杨云召的技术博客</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/C++%E6%9D%82%E8%B0%88/>C++杂谈</a><ul><li><a href=/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/>语法特性</a><ul><li><a href=/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/markdown/>属性关键字</a></li><li><a href=/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97/>属性关键字</a></li><li><a href=/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E5%88%A9%E5%99%A8/ class=active>内联变量——保证变量唯一性的利器</a></li></ul></li></ul></li><li><span>计算机基础</span><ul><li><span>编译原理</span><ul></ul></li><li><span>计算机网络</span><ul></ul></li></ul></li></ul><ul><li><a href=https://github.com/yangyunzhao/ target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>内联变量——保证变量唯一性的利器</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#内联变量保证变量唯一性的利器>内联变量——保证变量唯一性的利器</a></li></ul></nav></aside></header><article class="markdown book-article"><blockquote><p>本文是转载，出处不可考</p></blockquote><h1 id=内联变量保证变量唯一性的利器>内联变量——保证变量唯一性的利器
<a class=anchor href=#%e5%86%85%e8%81%94%e5%8f%98%e9%87%8f%e4%bf%9d%e8%af%81%e5%8f%98%e9%87%8f%e5%94%af%e4%b8%80%e6%80%a7%e7%9a%84%e5%88%a9%e5%99%a8>#</a></h1><p>在 C++ 中，一个定义了全局变量的头文件被多个源文件包含时，每个源文件都会创建该全局变量的一个实例，这可能导致链接时出现重定义错误，代码示例如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// example.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#ifndef EXAMPLE_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EXAMPLE_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> globalVar <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// EXAMPLE_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// file1.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;example.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>// Some code using globalVar
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// file2.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;example.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>// Some other code using globalVar
</span></span></span></code></pre></div><p>头文件中的变量globalVar会在file1.cpp和file2.cpp中分别创建实例，出现重定义的链接错误，MSVC的错误为LNK2005和LNK1169。</p><p>这是小编遇到的实际问题，在封装spdlog时，为了在宏内使用封装的对象，定义了全局变量，由于该日志类头文件被多个文件包含出现了链接错误。简化后的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//log.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Log logger;
</span></span><span style=display:flex><span><span style=color:#75715e>// Define macros for different log levels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define LOG_DEBUG(msg) logger.Log(LogLevel::Debug,__FUNCTION__,__LINE__, msg)
</span></span></span></code></pre></div><p>为了解决全局变量的重定义问题，C++17引入了内联变量的概念。</p><p><strong>内联变量</strong></p><p>使用 inline 关键字可以将变量声明为内联变量，在多个源文件中包含该头文件时，编译器只会创建一个该变量的实例。</p><p>如上实例中定义的全局变量globalVar可以修改为内敛变量，如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// example.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#ifndef EXAMPLE_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EXAMPLE_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> globalVar <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// EXAMPLE_H
</span></span></span></code></pre></div><p><strong>使用场景</strong></p><p><strong>1.</strong> <strong>头文件中定义全局变量</strong>，保证变量定义的唯一性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// constants.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#ifndef CONSTANTS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CONSTANTS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>double</span> PI <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14159265358979323846</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>constexpr</span> std<span style=color:#f92672>::</span>string AppName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;MyApp&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// CONSTANTS_H
</span></span></span></code></pre></div><p><strong>2.</strong> <strong>类的静态成员变量</strong></p><p>可以用来定义模板类的内联静态成员变量，也可以用来定义普通类的内联静态成员，只是普通类的静态成员变量通常来讲定义在源文件内，没必要内联。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// template_class.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#ifndef TEMPLATE_CLASS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TEMPLATE_CLASS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> T defaultValue <span style=color:#f92672>=</span> T();
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// TEMPLATE_CLASS_H
</span></span></span></code></pre></div><p><strong>注意事项</strong></p><p>内联变量有诸多的便利性，但是使用时仍需注意以下几点：</p><ul><li>必须在定义处进行初始化：内联变量的初始化必须在声明处完成。</li><li>不要在多个源文件中定义相同的内联变量：虽然编译器只会保留一个实例，但仍然不建议在多个源文件中定义相同的内联变量，以避免混乱和不必要的复杂性。</li><li>不要过度使用内联变量，每个编译单元都会维护一个内联变量的副本，如果定义过多的内联变量，不仅会导致程序占用大量的内存空间，也会增加编译时间。</li></ul><p><strong>总结</strong></p><p>内联变量是 C++17 新增的特性，用于解决头文件中变量多实例化的问题。通过使用inline将变量声明为内联变量，可以确保在多个源文件中只有一个变量实例，避免了链接时的重定义错误。然而，仍需要谨慎使用内联变量，并注意其初始化和定义的位置，以确保程序的正确性和可维护性。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#内联变量保证变量唯一性的利器>内联变量——保证变量唯一性的利器</a></li></ul></nav></div></aside></main></body></html>