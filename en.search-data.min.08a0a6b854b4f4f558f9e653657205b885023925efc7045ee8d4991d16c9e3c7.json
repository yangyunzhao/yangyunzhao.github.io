[{"id":0,"href":"/C++%E6%9D%82%E8%B0%88/","title":"C++杂谈","section":"首页","content":"\rC++杂谈\r#\r欢迎来到“C++杂谈”栏目，这里我们将深入探讨C++语言的多方面内容。\n栏目内容\r#\r在“C++杂谈”栏目中，我们将覆盖以下几个主题：\n编程技巧：分享实用的C++编程技巧，写出更高效、更安全的代码。 注意事项：讨论C++开发中常见的陷阱和误区，以及如何避免这些常见错误。 开源库介绍：探索和评测C++领域内的各种知名开源库，选择合适的工具来加速开发过程。 新语法特性：随着C++标准的不断进化，新的语法特性不断出现。解析这些新特性的用法和优势，保持最新的技术视野。 索引\r#\r语法特性\r#\r- 内联变量——保证变量唯一性的利器\n"},{"id":1,"href":"/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/","title":"语法特性","section":"C++杂谈","content":"\r文件索引\r#\r欢迎来到本文件索引页面，这里列出了所有重要的文档和资源，方便快速找到所需信息。\n- 内联变量——保证变量唯一性的利器\n"},{"id":2,"href":"/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E5%88%A9%E5%99%A8/","title":"内联变量——保证变量唯一性的利器","section":"语法特性","content":" 本文是转载，出处不可考\n内联变量——保证变量唯一性的利器\r#\r在 C++ 中，一个定义了全局变量的头文件被多个源文件包含时，每个源文件都会创建该全局变量的一个实例，这可能导致链接时出现重定义错误，代码示例如下。\n// example.h #ifndef EXAMPLE_H #define EXAMPLE_H int globalVar = 42; #endif // EXAMPLE_H // file1.cpp #include \u0026#34;example.h\u0026#34; // Some code using globalVar // file2.cpp #include \u0026#34;example.h\u0026#34; // Some other code using globalVar 头文件中的变量globalVar会在file1.cpp和file2.cpp中分别创建实例，出现重定义的链接错误，MSVC的错误为LNK2005和LNK1169。\n这是小编遇到的实际问题，在封装spdlog时，为了在宏内使用封装的对象，定义了全局变量，由于该日志类头文件被多个文件包含出现了链接错误。简化后的代码如下：\n//log.h Log logger; // Define macros for different log levels #define LOG_DEBUG(msg) logger.Log(LogLevel::Debug,__FUNCTION__,__LINE__, msg) 为了解决全局变量的重定义问题，C++17引入了内联变量的概念。\n内联变量\n使用 inline 关键字可以将变量声明为内联变量，在多个源文件中包含该头文件时，编译器只会创建一个该变量的实例。\n如上实例中定义的全局变量globalVar可以修改为内敛变量，如下\n// example.h #ifndef EXAMPLE_H #define EXAMPLE_H inline int globalVar = 42; #endif // EXAMPLE_H 使用场景\n1. 头文件中定义全局变量，保证变量定义的唯一性\n// constants.h #ifndef CONSTANTS_H #define CONSTANTS_H inline constexpr double PI = 3.14159265358979323846; inline constexpr std::string AppName = \u0026#34;MyApp\u0026#34;; #endif // CONSTANTS_H 2. 类的静态成员变量\n可以用来定义模板类的内联静态成员变量，也可以用来定义普通类的内联静态成员，只是普通类的静态成员变量通常来讲定义在源文件内，没必要内联。\n// template_class.h #ifndef TEMPLATE_CLASS_H #define TEMPLATE_CLASS_H template\u0026lt;typename T\u0026gt;class MyClass { public: static inline T defaultValue = T(); }; #endif // TEMPLATE_CLASS_H 注意事项\n内联变量有诸多的便利性，但是使用时仍需注意以下几点：\n必须在定义处进行初始化：内联变量的初始化必须在声明处完成。 不要在多个源文件中定义相同的内联变量：虽然编译器只会保留一个实例，但仍然不建议在多个源文件中定义相同的内联变量，以避免混乱和不必要的复杂性。 不要过度使用内联变量，每个编译单元都会维护一个内联变量的副本，如果定义过多的内联变量，不仅会导致程序占用大量的内存空间，也会增加编译时间。 总结\n内联变量是 C++17 新增的特性，用于解决头文件中变量多实例化的问题。通过使用inline将变量声明为内联变量，可以确保在多个源文件中只有一个变量实例，避免了链接时的重定义错误。然而，仍需要谨慎使用内联变量，并注意其初始化和定义的位置，以确保程序的正确性和可维护性。\n"}]