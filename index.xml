<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首页 on 杨云召的技术博客</title><link>https://example.com/</link><description>Recent content in 首页 on 杨云召的技术博客</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml"/><item><title>属性关键字</title><link>https://example.com/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Wed, 10 Apr 2024 16:03:07 +0800</pubDate><guid>https://example.com/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>本文是转载，出处不可考
属性关键字 # 现代C++引入了属性关键字，旨在为编译器提供更多的信息，以便进行优化或发出警告和错误。这些属性关键字不改变程序的逻辑，但它们对于提高代码的可读性、维护性和性能非常有用。以下是一些常用的C++属性关键字及其使用示例：
1. [[nodiscard]] # [[nodiscard]]属性用于强调函数的返回值不应被忽略，如果调用者未使用该函数的返回值，编译器将发出警告。
[[nodiscard]] int compute() { return 42; } void nodiscardExample() { compute(); // 这里会产生警告，因为忽略了返回值 int value = compute(); // 没有警告，因为使用了返回值 } 2. [[maybe_unused]] # [[maybe_unused]]属性用于指示变量或函数可能未被使用，从而避免在未使用变量或函数时编译器发出的警告。
[[maybe_unused]] void helperFunction() { // 可能不会被调用的函数 } void maybeUnusedExample() { [[maybe_unused]] int unusedVariable = 42; // 可能不会被使用的变量 } 3. [[deprecated]] 和 [[deprecated(&amp;quot;reason&amp;quot;)]] # [[deprecated]]属性用于标记已弃用的实体。可以提供一个字符串字面量作为参数，说明弃用的原因。
[[deprecated(&amp;#34;Use newFunction instead&amp;#34;)]] void oldFunction() { // 已弃用的函数 } void deprecatedExample() { oldFunction(); // 调用此函数时，编译器将发出弃用警告 } 4.</description></item><item><title>内联变量——保证变量唯一性的利器</title><link>https://example.com/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E5%88%A9%E5%99%A8/</link><pubDate>Wed, 10 Apr 2024 11:15:07 +0800</pubDate><guid>https://example.com/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E5%88%A9%E5%99%A8/</guid><description>本文是转载，出处不可考
内联变量——保证变量唯一性的利器 # 在 C++ 中，一个定义了全局变量的头文件被多个源文件包含时，每个源文件都会创建该全局变量的一个实例，这可能导致链接时出现重定义错误，代码示例如下。
// example.h #ifndef EXAMPLE_H #define EXAMPLE_H int globalVar = 42; #endif // EXAMPLE_H // file1.cpp #include &amp;#34;example.h&amp;#34; // Some code using globalVar // file2.cpp #include &amp;#34;example.h&amp;#34; // Some other code using globalVar 头文件中的变量globalVar会在file1.cpp和file2.cpp中分别创建实例，出现重定义的链接错误，MSVC的错误为LNK2005和LNK1169。
这是小编遇到的实际问题，在封装spdlog时，为了在宏内使用封装的对象，定义了全局变量，由于该日志类头文件被多个文件包含出现了链接错误。简化后的代码如下：
//log.h Log logger; // Define macros for different log levels #define LOG_DEBUG(msg) logger.Log(LogLevel::Debug,__FUNCTION__,__LINE__, msg) 为了解决全局变量的重定义问题，C++17引入了内联变量的概念。
内联变量
使用 inline 关键字可以将变量声明为内联变量，在多个源文件中包含该头文件时，编译器只会创建一个该变量的实例。
如上实例中定义的全局变量globalVar可以修改为内敛变量，如下
// example.h #ifndef EXAMPLE_H #define EXAMPLE_H inline int globalVar = 42; #endif // EXAMPLE_H 使用场景</description></item></channel></rss>