[{"id":0,"href":"/C++%E6%9D%82%E8%B0%88/","title":"C++杂谈","section":"首页","content":" C++杂谈 # 欢迎来到“C++杂谈”栏目，这里我们将深入探讨C++语言的多方面内容。\n栏目内容 # 在“C++杂谈”栏目中，我们将覆盖以下几个主题：\n编程技巧：分享实用的C++编程技巧，写出更高效、更安全的代码。 注意事项：讨论C++开发中常见的陷阱和误区，以及如何避免这些常见错误。 开源库介绍：探索和评测C++领域内的各种知名开源库，选择合适的工具来加速开发过程。 新语法特性：随着C++标准的不断进化，新的语法特性不断出现。解析这些新特性的用法和优势，保持最新的技术视野。 索引 # 语法特性 # 内联变量——保证变量唯一性的利器\n属性关键字\n"},{"id":1,"href":"/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/","title":"语法特性","section":"C++杂谈","content":" 语法特性 # 欢迎来到本文件索引页面，这里列出了所有重要的文档和资源，方便快速找到所需信息。\n内联变量——保证变量唯一性的利器 属性关键字 "},{"id":2,"href":"/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/markdown/","title":"属性关键字","section":"语法特性","content":"flowchart LR %% this is a comment A -- text --\u0026gt; B{node} A -- text --\u0026gt; B -- text2 --\u0026gt; C sequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? John--\u003e\u003eAlice: Great! Alice-)John: See you later! sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! "},{"id":3,"href":"/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97/","title":"属性关键字","section":"语法特性","content":" 本文是转载，出处不可考\n属性关键字 # 现代C++引入了属性关键字，旨在为编译器提供更多的信息，以便进行优化或发出警告和错误。这些属性关键字不改变程序的逻辑，但它们对于提高代码的可读性、维护性和性能非常有用。以下是一些常用的C++属性关键字及其使用示例：\n1. [[nodiscard]] # [[nodiscard]]属性用于强调函数的返回值不应被忽略，如果调用者未使用该函数的返回值，编译器将发出警告。\n[[nodiscard]] int compute() { return 42; } void nodiscardExample() { compute(); // 这里会产生警告，因为忽略了返回值 int value = compute(); // 没有警告，因为使用了返回值 } 2. [[maybe_unused]] # [[maybe_unused]]属性用于指示变量或函数可能未被使用，从而避免在未使用变量或函数时编译器发出的警告。\n[[maybe_unused]] void helperFunction() { // 可能不会被调用的函数 } void maybeUnusedExample() { [[maybe_unused]] int unusedVariable = 42; // 可能不会被使用的变量 } 3. [[deprecated]] 和 [[deprecated(\u0026quot;reason\u0026quot;)]] # [[deprecated]]属性用于标记已弃用的实体。可以提供一个字符串字面量作为参数，说明弃用的原因。\n[[deprecated(\u0026#34;Use newFunction instead\u0026#34;)]] void oldFunction() { // 已弃用的函数 } void deprecatedExample() { oldFunction(); // 调用此函数时，编译器将发出弃用警告 } 4. [[fallthrough]] # 在switch语句中，[[fallthrough]]属性用于明确指示允许从一个case标签向下“穿透”到下一个case标签，这样可以避免编译器关于非故意的case穿透的警告。\nvoid fallthroughExample(int num) { switch (num) { case 1: std::cout \u0026lt;\u0026lt; \u0026#34;1\u0026#34;; [[fallthrough]]; case 2: std::cout \u0026lt;\u0026lt; \u0026#34;2\u0026#34;; break; default: std::cout \u0026lt;\u0026lt; \u0026#34;Other\u0026#34;; } } 5. [[likely]] 和 [[unlikely]] (C++20) # C++20引入了[[likely]]和[[unlikely]]属性，用于告知编译器某个条件分支的可能性，以帮助优化生成的代码。\nvoid likelyExample(int num) { if (num == 42) [[likely]] { std::cout \u0026lt;\u0026lt; \u0026#34;It\u0026#39;s 42\u0026#34;; } else [[unlikely]] { std::cout \u0026lt;\u0026lt; \u0026#34;Not 42\u0026#34;; } } 通过上述示例，可以看到C++属性关键字如何帮助开发者向编译器提供额外的信息，从而优化代码、生成警告或改进代码可读性。\n"},{"id":4,"href":"/C++%E6%9D%82%E8%B0%88/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E5%88%A9%E5%99%A8/","title":"内联变量——保证变量唯一性的利器","section":"语法特性","content":" 本文是转载，出处不可考\n内联变量——保证变量唯一性的利器 # 在 C++ 中，一个定义了全局变量的头文件被多个源文件包含时，每个源文件都会创建该全局变量的一个实例，这可能导致链接时出现重定义错误，代码示例如下。\n// example.h #ifndef EXAMPLE_H #define EXAMPLE_H int globalVar = 42; #endif // EXAMPLE_H // file1.cpp #include \u0026#34;example.h\u0026#34; // Some code using globalVar // file2.cpp #include \u0026#34;example.h\u0026#34; // Some other code using globalVar 头文件中的变量globalVar会在file1.cpp和file2.cpp中分别创建实例，出现重定义的链接错误，MSVC的错误为LNK2005和LNK1169。\n这是小编遇到的实际问题，在封装spdlog时，为了在宏内使用封装的对象，定义了全局变量，由于该日志类头文件被多个文件包含出现了链接错误。简化后的代码如下：\n//log.h Log logger; // Define macros for different log levels #define LOG_DEBUG(msg) logger.Log(LogLevel::Debug,__FUNCTION__,__LINE__, msg) 为了解决全局变量的重定义问题，C++17引入了内联变量的概念。\n内联变量\n使用 inline 关键字可以将变量声明为内联变量，在多个源文件中包含该头文件时，编译器只会创建一个该变量的实例。\n如上实例中定义的全局变量globalVar可以修改为内敛变量，如下\n// example.h #ifndef EXAMPLE_H #define EXAMPLE_H inline int globalVar = 42; #endif // EXAMPLE_H 使用场景\n1. 头文件中定义全局变量，保证变量定义的唯一性\n// constants.h #ifndef CONSTANTS_H #define CONSTANTS_H inline constexpr double PI = 3.14159265358979323846; inline constexpr std::string AppName = \u0026#34;MyApp\u0026#34;; #endif // CONSTANTS_H 2. 类的静态成员变量\n可以用来定义模板类的内联静态成员变量，也可以用来定义普通类的内联静态成员，只是普通类的静态成员变量通常来讲定义在源文件内，没必要内联。\n// template_class.h #ifndef TEMPLATE_CLASS_H #define TEMPLATE_CLASS_H template\u0026lt;typename T\u0026gt;class MyClass { public: static inline T defaultValue = T(); }; #endif // TEMPLATE_CLASS_H 注意事项\n内联变量有诸多的便利性，但是使用时仍需注意以下几点：\n必须在定义处进行初始化：内联变量的初始化必须在声明处完成。 不要在多个源文件中定义相同的内联变量：虽然编译器只会保留一个实例，但仍然不建议在多个源文件中定义相同的内联变量，以避免混乱和不必要的复杂性。 不要过度使用内联变量，每个编译单元都会维护一个内联变量的副本，如果定义过多的内联变量，不仅会导致程序占用大量的内存空间，也会增加编译时间。 总结\n内联变量是 C++17 新增的特性，用于解决头文件中变量多实例化的问题。通过使用inline将变量声明为内联变量，可以确保在多个源文件中只有一个变量实例，避免了链接时的重定义错误。然而，仍需要谨慎使用内联变量，并注意其初始化和定义的位置，以确保程序的正确性和可维护性。\n"}]